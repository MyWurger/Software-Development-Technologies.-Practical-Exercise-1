/*******************************************************************************
 * Лабораторная работа №1 по дисциплине "Программирование"                     *
 *-----------------------------------------------------------------------------*
 * Project Type  : Win64 Console Application                                   *
 * Project Name  : Функции и последовательности чисел                          *
 * File Name     : Функции и последовательности чисел.cpp                      *
 * Programmer(s) :                                                             *
 * Modifyed By   :                                                             *
 * Created       : 15/09/25                                                    *
 * Last Revision : 24/09/25                                                    *
 * Comment(s)    : Формирование последовательностей (упорядоченные и           *
 *                 неупорядоченные массивы), измерение последовательностей и   *
 *                 частично упорядоченные последовательности. Формирование     *
 *                 последовательностей на экране                                *
 *******************************************************************************/

#include "sequences.h"

/***************************************************/
/*             РЕАЛИЗАЦИЯ ФУНКЦИЙ                 */
/***************************************************/

/*-------------------------------------------------*/
/* Функция вывода меню */
/*-----------------------------------*/
void pechatusloviy()
{
    setlocale(LC_ALL, "Rus");                  // Установка русской локали
    cout << "+------------------------------+" << endl;
    cout << "|     Выберите функцию:       |" << endl;
    cout << "+------------------------------+" << endl;
    cout << "|      1. sluchainaya         |" << endl;
    cout << "+------------------------------+" << endl;
    cout << "|      2. ubivaushaya         |" << endl;
    cout << "+------------------------------+" << endl;
    cout << "|      3. vozrastaushaya      |" << endl;
    cout << "+------------------------------+" << endl;
    cout << "|      4. pila                |" << endl;
    cout << "+------------------------------+" << endl;
    cout << "|      5. stupenka            |" << endl;
    cout << "+------------------------------+" << endl;
    cout << "|      6. kvazi               |" << endl;
    cout << "+------------------------------+" << endl;
    cout << "|      7. sinus               |" << endl;
    cout << "+------------------------------+" << endl;
    cout << "|      8: Exit.               |" << endl;
    cout << "+------------------------------+" << endl;
    return;
}

/*-------------------------------------------------*/
/* Возрастающая последовательность */
/*-------------------------------------------*/
int linevozrastanie(int* pznachenue, int number, const int rand_max)
{
    *(pznachenue + 0) = rand() % rand_max;     // Задаем последовательность для первого элемента

    // Формирование остальных элементов последовательности, начиная со 2-го
    for (int n = 1; n < number; n++) 
    {
        *(pznachenue + n) = *(pznachenue + (n - 1)) + rand() % rand_max + 1; // Каждый следующий элемент больше предыдущего на случайное число
    }
    return 0;                                  // Завершение функции
}

/*-------------------------------------------------*/
/* Убывающая последовательность    */
/*-------------------------------------------*/
int lineubuvanie(int * pznachenue, int number, const int rand_max)
{
    *(pznachenue + 0) = rand_max * 100;        // Задаем последовательность для первого элемента

    // Формирование остальных элементов последовательности, начиная со 2-го
    for (int n = 1; n < number; n++)
    {
        *(pznachenue + n) = *(pznachenue + (n - 1)) - (rand() % rand_max); // Каждый следующий элемент меньше предыдущего на случайное число
    }
    return 0;                                  // Завершение функции
}

/*-------------------------------------------------*/
/* Случайная последовательность             */
/*-------------------------------------------*/
int slucaynaya(int* pznachenue, int number, const int rand_max)
{
    // Формирование всех элементов последовательности, начиная с 1-го
    for (int n = 0; n < number; n++)
    {
        *(pznachenue + n) = rand() % rand_max * 100 + rand() % rand_max * 10 + rand() % rand_max + n; // Генерируем случайное число в заданном диапазоне
    }
    return 0;                                  // Завершение функции
}

/*-------------------------------------------------*/
/* Пилообразная последовательность             */
/*----------------------------------------------*/
int piloobraznaya(int* pznachenue, int number, const int rand_max)
{
    *(pznachenue + 0) = rand_max * 3;          // Задаем последовательность для первого элемента
    // Формирование остальных элементов последовательности, начиная со 2-го
    for (int n = 1; n < number; n++)     
    {
        if (n != interval)                     // Если элемент не в интервале
        {
            *(pznachenue + n) = *(pznachenue + (n - 1)) + (rand() % rand_max * 6); // Каждый следующий элемент больше предыдущего на случайное число
        }

        if ((n + 2) % interval == 0)           // Если третий элемент интервала (для пилообразной формы)
        {
            *(pznachenue + n) = *(pznachenue + 0) + rand_max * 5;                  // Сброс значения

        }

        if ((n + 1) % interval == 0)          // Если второй элемент интервала (для пилообразной формы). Устанавливаем на минимальное значение
        {
            *(pznachenue + n) = *(pznachenue + 0) + rand_max * 3;                  // Сброс значения
        }

        if (n % interval == 0)               // Если первый элемент интервала (для пилообразной формы). Устанавливаем на минимальное значение
        {
            *(pznachenue + n) = *(pznachenue + 0) + rand_max;                      // Сброс значения
        }
    }
    return 0;                                                                      // Завершение функции
}

/*-------------------------------------------------*/
/* Ступенчатая последовательность              */
/*----------------------------------------------*/
int stupenchataya(int* pznachenue, int number, const int rand_max)
{
    int stupenka = 10;                      // Высота ступеньки
    // Формирование всех элементов последовательности, начиная с 1-го
    for (int n = 0; n < number; n++)
    {
        if ((n % interval != 0) || (n==0))  // Если первый элемент интервала или в начале
        {
            *(pznachenue + n) = rand() % rand_max  + stupenka;      // Устанавливаем значения элементов ступеньки на случайное число плюс высота ступеньки
        }
        else                                // Иначе на новую ступеньку
        {
            *(pznachenue + n) = rand() % rand_max * 40 + stupenka;  // Устанавливаем новую высоту ступеньки 
        }
        stupenka = *(pznachenue + n) +3;   // Увеличиваем высоту, чтобы следующая была выше
    }
    return 0;                               // Завершение функции
}

/*-------------------------------------------------*/
/* Квази-упорядоченная последовательность      */
/*----------------------------------------------*/
int kvazi( int* pznachenue, int number, const int rand_max)
{
    int zamena = 0;                         // Для случайного элемента, на который будем менять
    int promeg = 0;                         // Для временного значения элемента
    *(pznachenue + 0) = (rand() % rand_max)*10+2;                             // Задаем последовательность для первого элемента
    // Формирование всех элементов, начиная со 2-го
    for (int n = 1; n < number; n++) 
    {
        *(pznachenue + n) = *(pznachenue + (n - 1)) + rand() % rand_max  + 3; // Каждый следующий элемент больше предыдущего на случайное число
    }
    // Перемешивание некоторых элементов массива, начиная со 2-го
    for (int n = 1; n < number; n++)
    {
        if (n % 20 == 0)                   // Если каждый 20-й
        {
            zamena = rand() % number   ;   // Выбираем случайный элемент массива, на который будем менять элементы массива
            promeg = *(pznachenue + n);    // Сохраняем текущий элемент, который будем менять
            *(pznachenue + n) = *(pznachenue + zamena);  // Меняем элемент, на тот, который выбрали случайно
            *(pznachenue + zamena) = promeg;             // Меняем элемент обратно
        }
    }
    return 0;                              // Завершение функции
}

/*-------------------------------------------------*/
/* Синусоидальная последовательность           */
/*----------------------------------------------*/
int sinus(int* pznachenue, int number, const int rand_max)
{
    int step = 1;                                                                // Для шага волны
    int ugol = 0;                                                                // Переменная для угла
    // Формирование всех элементов последовательности, начиная с 1-го
    for (int n = 0; n < number; n++)
    {
        ugol = (180 * step * n)/3.14;                                            // Вычисляем угол волны в радианах
        *(pznachenue + n) = int(sin(ugol)*100);                                  // Синус
        if (n % 10 == 0)                                                         // Добавляем случайности в синусоидальные значения для каждого 10-го элемента
        {
            *(pznachenue + n) = *(pznachenue + n) + rand()% (rand_max * 3);      // Добавляем в значение и еще случайное случайное значение
        }
    }
    return 0;                                             // Завершение функции
}

/*-------------------------------------------------*/
/* Выбор функции из меню                     */
/*----------------------------------------------*/
int(*MENU())(int*, int, const int)
{
    int choise;
    string name[8] = { "slucaynaya", "lineubuvanie", "linevozrastanie", "piloobraznaya", "stupenchataya","kvazi","sinus", "Exit." };
    int (*functions[])(int*, int, const int) = { slucaynaya, lineubuvanie, linevozrastanie, piloobraznaya, stupenchataya, kvazi, sinus };
    cout << "\nВыберите функцию: 1 - 8, где 8 - выход \n";
    cout << "Ваш выбор: ";
    cin >> choise;                                                              // Ввод выбранного пользователя
    if ((choise > 0) && (choise < 8))                                           // Если выбор в допустимом диапазоне
    {
        cout << "\t\t\t\t\t\tВЫБРАННАЯ   " << name[choise - 1] << endl << endl;           // Вывод названия алгоритма из массива
        return functions[choise - 1];                                           // Возвращаем соответствующую функцию
    }
    else
    {
        return NULL;                                                            // Возвращаем NULL - если выход
    }
}

/*-------------------------------------------------*/
/* Создание динамического массива               */
/*----------------------------------------------*/
void sozdanie(int** pznachenue, int& number)
{
    cout << "Введите количество элементов последовательности: ";
    cin >> number;                                                             // Ввод пользователем количества элементов массива
    cout << endl;                                                              // Переход на новую строку
    *pznachenue = new int[number];                                             // Создание динамического массива
    return ;                                                                   // Завершение функции
}

/*-------------------------------------------------*/
/* Удаление динамического массива               */
/*----------------------------------------------*/
void udalenie(int* pznachenue)
{
    delete [] pznachenue;                                                     // Удаление динамического массива
    return;                                                                   // Завершение функции
}

/*-------------------------------------------------*/
/* Вывод последовательности на экран            */
/*----------------------------------------------*/
void pechat_int_mass(int* pznachenue, int number, const int rand_max)
{

    int(*choise)(int*, int, const int);                                     // Указатель на функцию, возвращающую указатель
    while (1)                                                               // Бесконечный цикл работы программы до тех пор пока пользователь не выберет Exit.
    {  
        cout << "\t\t\t\t\t РАБОТА   С   ЦЕЛЫМИ   ЧИСЛАМИ\n\n";
        pechatusloviy();                                                    // Вывод меню программы
        choise = MENU();                                                    // Получение указателя на функцию из меню, возвращающую указатель
        if (choise == NULL)                                                 // Если пользователь выбрал выход
        {
            cout << " \t\t\t\tВЫХОД\n\n";
            cout << "Завершение программы для целых чисел\n";
        // system("pause");                                                    // Пауза (Windows only)
        cout << "Нажмите Enter для продолжения...";
        cin.ignore();
        cin.get();
        break;                                                          // Выход из цикла
        }
        sozdanie(&pznachenue, number);                                      // Создание динамического массива с заданным количеством элементов
        auto start = chrono::steady_clock::now();                           // Начало измерения времени работы
        choise(pznachenue, number, rand_max);                               // Вызов функции, выбранной из меню для генерации последовательности
        auto end = chrono::steady_clock::now();                             // Конец измерения времени работы
        cout << "\t\t\t\t ВЫПОЛНЕНИЕ ФУНКЦИИ, ФОРМИРУЮЩЕЙ АЛГОРИТМ: \n";
        cout << "+------------------------------+" << endl;        // Вывод верхней границы таблицы
        for (int j = 0; j < number; j++)                                    // Цикл по всем элементам массива, выводящий значения последовательности
        { 
            cout << "| " << setw(17) << setfill(' ') << *(pznachenue + j) << setw(11) << setfill(' ') << "| n = " << j + 1 << endl;
        }
        cout << "+------------------------------+" << endl;  // Вывод нижней границы таблицы
        setlocale(LC_ALL, "Rus");                                           // Установка русской локали 
        cout << "Время выполнения функции, формирующей алгоритм = " << chrono::duration_cast<chrono::microseconds>(end - start).count() << "  микросекунд; \n\n";             // Вывод на экран время работы
        // system("pause");                                                    // Пауза (Windows only)
        cout << "Нажмите Enter для продолжения...";
        cin.ignore();
        cin.get();
        system("clear");                                                    // Очистка экрана перед новой итерацией (Unix/macOS)
        udalenie(pznachenue);                                               // Очистка экрана перед новой итерацией удаляем память для новой итерации
    }
    return;                                                                 // Завершение функции
}

// Для чисел с плавающей точкой:
/*-------------------------------------------------*/
/* Возрастающая последовательность */
/*-------------------------------------------*/
double linevozrastanie(double *pznacheniedoub, int number, const int rand_max)
{
    *(pznacheniedoub+0) = rand() % rand_max + 5.678;                      // Задаем последовательность для первого элемента
    // Формирование остальных элементов последовательности, начиная со 2-го
    for (int n = 1; n < number; n++)
    {
        *(pznacheniedoub + n) = *(pznacheniedoub+(n - 1)) + double(rand() % rand_max + 1.43);   // Каждый следующий элемент больше предыдущего на случайное число
    }
    return 0;                                                             // Завершение функции
}

/*-------------------------------------------------*/
/* Убывающая последовательность    */
/*-------------------------------------------*/
double lineubuvanie(double* pznacheniedoub, int number, const int rand_max)
{
    *(pznacheniedoub + 0) = rand_max * 100.54;                             // Задаем последовательность для первого элемента
    
    // Формирование остальных элементов последовательности, начиная со 2-го
    for (int n = 1; n < number; n++)
    {
        *(pznacheniedoub + n) = *(pznacheniedoub + (n - 1)) - double(rand() % rand_max + 0.9486);  // Каждый следующий элемент меньше предыдущего на случайное число
    }
    return 0;                                                              // Завершение функции
}

/*-------------------------------------------------*/
/* Случайная последовательность             */
/*-------------------------------------------*/
double slucaynaya(double* pznacheniedoub, int number, const int rand_max)
{             
    // Формирование всех элементов последовательности, начиная с 1-го
    for (int n = 0; n < number; n++)
    {
        *(pznacheniedoub + n) = double(rand() % rand_max * 100.2 + rand() % rand_max * 12.6567 + rand() % rand_max*1.3456) + n;   // Генерируем случайное число в заданном диапазоне
    }
    return 0;                                                              // Завершение функции
}

/*-------------------------------------------------*/
/* Пилообразная последовательность             */
/*----------------------------------------------*/
double piloobraznaya(double* pznacheniedoub, int number, const int rand_max)
{ 
    *(pznacheniedoub + 0) = rand_max * 3.6754;                             // Задаем последовательность для первого элемента
    // Формирование остальных элементов последовательности, начиная со 2-го
    for (int n = 1; n < number; n++)
    {
        if (n != interval)                                                 // Если элемент не в интервале
        {
            *(pznacheniedoub + n) = *(pznacheniedoub + (n - 1)) + double(rand() % rand_max * 6.45);  // Каждый следующий элемент больше предыдущего на случайное число
        }

        if ((n + 2) % interval == 0)                                      // Если третий элемент интервала (для пилообразной формы)
        {
            *(pznacheniedoub + n) = *(pznacheniedoub + 0) + double(rand_max * 5.67);                 // Сброс значения

        }

        if ((n + 1) % interval == 0)                                      // Если второй элемент интервала (для пилообразной формы). Устанавливаем на минимальное значение
        {
            *(pznacheniedoub + n) = *(pznacheniedoub + 0) + double(rand_max * 3.32);                 // Сброс значения
        }

        if (n % interval == 0)                                            // Если первый элемент интервала (для пилообразной формы). Устанавливаем на минимальное значение           
        {
            *(pznacheniedoub + n) = *(pznacheniedoub + 0) + double(rand_max);                        // Сброс значения
        } 
    }
    return 0;
}

/*-------------------------------------------------*/
/* Ступенчатая последовательность              */
/*----------------------------------------------*/
double stupenchataya(double* pznacheniedoub, int number, const int rand_max)
{
    double stupenka = 20.234;                                             // Высота ступеньки
    // Формирование всех элементов последовательности, начиная с 1-го
    for (int n = 0; n < number; n++)
    {
        if ((n % interval != 0) || (n == 0))                              // Если первый элемент интервала или в начале          
        {
            *(pznacheniedoub + n) = rand() % rand_max + stupenka;         // Устанавливаем значения элементов ступеньки на случайное число плюс высота ступеньки     
        }
        else                                                              // Иначе на новую ступеньку
        {
            *(pznacheniedoub + n) = rand() % rand_max * 40.345 + stupenka;   // Устанавливаем новую высоту ступеньки 
        }
        stupenka = *(pznacheniedoub + n) + 3.4657;                           // Увеличиваем высоту, чтобы следующая была выше
    }
    return 0;                                                                // Завершение функции
}

/*-------------------------------------------------*/
/* Квази-упорядоченная последовательность      */
/*----------------------------------------------*/
double kvazi(double* pznacheniedoub, int number, const int rand_max)
{
    int zamena = 0;                                                           // Для случайного элемента, на который будем менять
    double promeg = 0;                                                        // Для временного значения элемента
    *(pznacheniedoub + 0) = (rand() % rand_max) * 10.34 + 2.132;              // Задаем последовательность для первого элемента
    // Формирование всех элементов, начиная со 2-го
    for (int n = 1; n < number; n++)
    {
        *(pznacheniedoub + n) = *(pznacheniedoub + (n - 1)) + rand() % rand_max + 3.345; // Каждый следующий элемент больше предыдущего на случайное число
    }
    // Перемешивание некоторых элементов массива, начиная со 2-го
    for (int n = 1; n < number; n++)
    {
        if (n % 20 == 0)                                                      // Если каждый 20-й           
        {
            zamena = rand() % number;                                         // Выбираем случайный элемент массива, на который будем менять элементы массива     
            promeg = *(pznacheniedoub + n);                                   // Сохраняем текущий элемент, который будем менять        
            *(pznacheniedoub + n) = *(pznacheniedoub + zamena);               // Меняем элемент, на тот, который выбрали случайно
            *(pznacheniedoub + zamena) = promeg;                              // Меняем элемент обратно
        }
    }
    return 0;                                                                 // Завершение функции
}

/*-------------------------------------------------*/
/* Синусоидальная последовательность           */
/*----------------------------------------------*/
double sinus(double* pznacheniedoub, int number, const int rand_max)
{
    double step = 1;                                                         // Для шага волны                    
    double ugol = 0.1;                                                       // Переменная для угла
    // Формирование всех элементов последовательности, начиная с 1-го
    for (int n = 0; n < number; n++)
    {
        ugol = (180 * step * n) / 3.14;                                      // Вычисляем угол волны в радианах
        *(pznacheniedoub + n) = double(sin(ugol) * 100);                     // Синус
        if (n % 10 == 0)                                                     // Добавляем случайности в синусоидальные значения
        {
            *(pznacheniedoub + n) = *(pznacheniedoub + n) + rand() % (rand_max * 3) + 0.345;  // Добавляем в значение и еще случайное случайное значение
        }
    }
    return 0;
}

/*-------------------------------------------------*/
/* Выбор функции из меню                     */
/*----------------------------------------------*/
double (*MENU2())(double*, int, const int)
{
    int choisedoub;                                                         // Выбор пользователя
    string name[8] = { "slucaynaya", "lineubuvanie", "linevozrastanie", "piloobraznaya", "stupenchataya","kvazi","sinus", "Exit." };
    double (*functionsdoub[])(double*, int, const int) = { slucaynaya, lineubuvanie, linevozrastanie, piloobraznaya, stupenchataya, kvazi, sinus };
    cout << "\nВыберите функцию: 1 - 8, где 8 - выход \n";
    cout << "Ваш выбор: ";
    cin >> choisedoub;                                                       // Ввод выбора пользователя           
    if ((choisedoub > 0) && (choisedoub) < 8)                                // Если выбор в допустимом диапазоне
    {
        cout << "\t\t\t\t\t\tВЫБРАННАЯ   " << name[choisedoub - 1] << endl << endl;           // Вывод названия алгоритма из массива
        return functionsdoub[choisedoub - 1];                                // Возвращаем соответствующую функцию
    }
    else
    {
        return NULL;                                                         // Возвращаем NULL - если выход
    }
}

/*-------------------------------------------------*/
/* Создание динамического массива               */
/*----------------------------------------------*/
void sozdanie(double** pznacheniedoub, int& number)
{
    cout << "Введите количество элементов последовательности: ";
    cin >> number;                                                           // Ввод пользователем количества элементов массива                                   
    cout << endl;
    *pznacheniedoub = new double[number];                                    // Создание динамического массива         
    return;                                                                  // Завершение функции         
}

/*-------------------------------------------------*/
/* Удаление динамического массива               */
/*----------------------------------------------*/
void udalenie(double* pznacheniedoub)
{
    delete[] pznacheniedoub;                                                 // Удаление динамического массива        
    return;                                                                  // Завершение функции          
}

/*-------------------------------------------------*/
/* Вывод последовательности на экран            */
/*----------------------------------------------*/
void pechat_doub_mass(double pznacheniedoub[], int number, const int rand_max)
{

    double(*choisedoub)(double*, int, const int);                            // Указатель на функцию, возвращающую указатель          
    while (1)                                                                // Бесконечный цикл работы программы до тех пор пока пользователь не выберет Exit.        
    {
        cout << "\t\t\t\t РАБОТА   С    ЧИСЛАМИ   C   ПЛАВАЮЩЕЙ   ТОЧКОЙ   ЧИСЛАМИ \n\n";
        pechatusloviy();                                                     // Вывод меню программы          
        choisedoub = MENU2();                                                // Получение указателя на функцию из меню, возвращающую указатель
        if (choisedoub == NULL)                                              // Если пользователь выбрал выход
        {
            cout << " \t\t\t\tВЫХОД\n\n";
            cout << "Завершение программы для чисел с плавающей точкой\n";
            break;                                                           // Выход из цикла         
        }
        sozdanie(&pznacheniedoub, number);                                   // Создание динамического массива с заданным количеством элементов         
        auto start = chrono::steady_clock::now();                            // Начало измерения времени работы функции
        choisedoub(pznacheniedoub, number, rand_max);                        // Вызов функции, выбранной из меню для генерации последовательности
        auto end = chrono::steady_clock::now();                              // Конец измерения времени работы функции
        cout << "\t\t\t МАССИВ   СФОРМИРОВАННЫЙ   ФУНКЦИЕЙ   С   ПЛАВАЮЩЕЙ   ТОЧКОЙ   ЧИСЛАМИ \n";
        cout << "+------------------------------+" << endl;   // Вывод верхней границы таблицы        
        for (int j = 0; j < number; j++)                                     // Цикл по всем элементам массива, выводящий значения последовательности                 
        {
            cout << "| " << setw(17) << setfill(' ') << *(pznacheniedoub + j) << setw(11) << setfill(' ') << "| n = " << j + 1 << endl;
        }
        cout << "+------------------------------+" << endl;    // Вывод нижней границы таблицы
        setlocale(LC_ALL, "Rus");                                             // Установка русской локали
        cout << "Время выполнения функции, формирующей алгоритм = " << chrono::duration_cast<chrono::microseconds>(end - start).count() << "  микросекунд; \n\n";            // Вывод на экран время работы функции
        // system("pause");                                                    // Пауза (Windows only)
        cout << "Нажмите Enter для продолжения...";
        cin.ignore();
        cin.get();
        system("clear");                                                      // Очистка экрана перед новой итерацией (Unix/macOS)
        udalenie(pznacheniedoub);                                             // Очистка экрана перед новой итерацией удаляем память для новой итерации        
    }
    return;                                                                   // Завершение функции      
}
